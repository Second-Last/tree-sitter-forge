#lang forge/froglet

abstract sig StackState {
    -- The top of the stack in this state (may be empty)
    top: lone StackElement
}
-- There are only 3 states in the model: Initial -> Mid -> End
one sig Initial, Mid, End extends StackState {} 

sig StackElement {
    prev: lone StackElement
}

// DO NOT EDIT above this line

// Write your comments explaining why you would care about checking the example 
// property given in the handout:
// 
// Because this property is the entire reason we're using a stack! A push and a
// pop should not change anything about the stack, which allows us to retrieve
// previously push-ed items.
//
// For example, if this property is not obeyed, you can't reliably retrieve
// anything that was pushed more than 1 push-operation ago. After push A -> push
// B -> pop, we're not guaranteed to have A on the top of the stack; it could be
// C, D, or anything else, which breaks our assumptions on how stacks should
// function. We should be guaranteed an A on the top of the stack at this point.

// Which combination of constraints produces the visualization on the assignment
// page?
// 
// 1. If we perform a push, followed by a pop, the stack is in the state it was
//    before the push.
// 2. The stack elments don't form a loop.
// 3. Initial and Mid are separated by exactly one operation (i.e. their .top)
//    are connected by a `prev`.
// 4. Mid and End are separated by exactly one operation (i.e. their .top)
//    are connected by a `prev`.

pred init {
    // Fill me in!
    // Write a constraint that the stack in the Initial state is linear
    //  (do not use the "is linear" bounds annotation; write a constraint
	//	instead)
	all s1, s2 : StackElement | {
		// avoid self loop
		s1.prev != s1
		// don't form a loop in general
		s1 != s2 => {
			not {
				reachable[s1, s2, prev]
				reachable[s2, s1, prev]
			}
		}
	}

    // Write a constraint that all stack elements are accessible from some
	// state
	all s : StackElement | some st : StackState | {
		s = st.top or reachable[s, st.top, prev]
	}
}

pred InitialToMidPop{
    // Fill me in!
    // When you pop an element between Initial and Mid
    Initial.top.prev = Mid.top
	// Prevent the `none` case
	some Mid.top
}

pred InitialToMidPush {
    // Fill me in!
    // When you push an element between Initial and Mid
    Mid.top.prev = Initial.top
	some Initial.top
}

pred MidToEndPop {
    // Fill me in !
    // When you pop an element between Mid and End
    Mid.top.prev = End.top
	some End.top
}

pred MidToEndPush{
    // Fill me in !
    // When you push an element between Mid and End
    End.top.prev = Mid.top
	some Mid.top
}

// Run the following after you finish writing your predicates
// What do you see? Are there properties being violated? 
run {
    init
    InitialToMidPush
    MidToEndPush
}
run {
    init 
    InitialToMidPop
    MidToEndPush
}
